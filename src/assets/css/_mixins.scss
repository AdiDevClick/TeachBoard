@use "sass:string" as string;
@use "sass:math" as math;
@use "sass:meta" as meta;
@use "sass:list" as list;
@use "sass:map" as map;

/**
  * _mixins.scss
  * Collection of reusable Sass mixins for styling.
  */

/**
  * DEFINE A CUSTOM CSS @Property.
  *
  * @param {string} $variable - The name of the CSS variable (without '--').
      => You can provide either quoted or unquoted names.

  * @param {string} $syntax - The syntax for the property (e.g., '<number>', 'percentage', '<color>').
      => You can provide either 'percentage' or '<percentage>'.

  * @param {boolean} $inherits - Whether the property inherits its value - (default: true)
  * @param {string} $initial-value - The initial value of the property.

  * @example:

  @include property('slider-progress', 'percentage', true, 25%);
  @include property(slider-progress, percentage, true, 25%);
  @include property(slider-progress, '<percentage>', true, 25%);
    => Each of them will define the same property.
  */
@mixin property($variable: variable, $syntax: "<number>", $inherits: true,
  $initial-value: 0) {
  // ensure variable name isn't quoted
  $name: string.unquote($variable);

  // normalize syntax: accept both 'percentage' and '<percentage>' and ensure it's wrapped with <> for @property
  @if string.index($syntax, '<')==null or string.index($syntax, '>')==null {
    $syntax: '<#{$syntax}>';
  }


  @property --#{$name} {
    syntax: $syntax;
    inherits: $inherits;
    initial-value: $initial-value;
  }
}

/**
  * DEFINE MAX WIDTH CONTENT FOR THE MAIN CONTAINER USING A CROP MARGIN
  *
  * @param {string} $max-width-content - The maximum width of the content area.
  * @param {string} $width-crop - The amount to crop from each side of the element.
  *
  * @example:
  * @include apply-width-crop(1200px, 16px);
  */
@mixin apply-width-crop($max-width-content, $width-crop) {
  width: min($max-width-content, calc(100% - ($width-crop * 2)));
}

/**
  * APPLY REPEATED LINEAR GRADIENT FOR SLIDER
  *
  * @param {string} $degree - The angle of the gradient (e.g., '90deg').
  * @param {string} $variable - The CSS variable representing the progress (e.g., '--slider-progress').
  * @param {list} $ticks - A list of tick positions in percentages (default: 0 25 50).
  * @param {string} $thickness - The thickness of the tick marks (default: 1px).
  * @param {string} $color - The color of the tick marks (default: #fff).
  *
  * @example:
  * @include apply-repeated-linear-gradient-for-slider(90deg, '--slider-progress', 0 25 50, 1px, #fff);
  */
@mixin apply-repeated-linear-gradient-for-slider($degree, $variable, $ticks: 0 25 50, $thickness: 1px, $color: #fff) {

  // build separators list (top layers first)
  $gradients: (
  );

@each $t in $ticks {
  $slice: linear-gradient($degree, transparent 0, transparent calc(var($variable) + ($t * 1%) - $thickness), $color calc(var($variable) + ($t * 1%) - $thickness), $color calc(var($variable) + ($t * 1%) + $thickness), transparent calc(var($variable) + ($t * 1%) + $thickness));
  $gradients: list.append($gradients, $slice, comma);
}

// join separators and base into a single background value
$bg: '';

@for $i from 1 through list.length($gradients) {
  @if $i ==1 {
    $bg: list.nth($gradients, $i);
  }

  @else {
    $bg: $bg, list.nth($gradients, $i);
  }
}

$bg: $bg;

background: $bg;
}

/**
  * REGISTER A BEM CLASS AS AN ALIAS
  * @param {string} $key - The alias key to register.
  * @example:
  * @include register-alias('leftNumber');
  */
@mixin register-alias($currentSelector, $key, $bem-prefix, $alias-map: ()) {
  // ex current selector: ".evaluation-page__content--container"
  $sel: $currentSelector;
  // get substring after the first dot (handles selectors like ":global .evaluation-page--container")
  $dot-pos: string.index($sel, ".");

  @if $dot-pos ==null {
    $sel-name: $sel;
  }

  @else {
    $sel-name: string.slice($sel, $dot-pos + 1);
  }

  // We need to extract the relative fragment after the BEM prefix (or it will not work properly and display "evaluation-pageevaluation-page__content--container")

  // compute the relative fragment after the BEM prefix
  $start-pos: string.length($bem-prefix) + 1;
  // start at first char after prefix
  $relative: string.slice($sel-name, $start-pos);

  // store as a single-item list (so it's compatible with existing $alias-map structure)
  $alias-map: map.merge($alias-map, ($key: (
        $relative))) !global;
}

/**
  * CREATE EXPORT ALIASES FOR EASIER JS USAGE
  *
  * @param {string} $bem-prefix - The BEM prefix for the class names.
  * @param {map} $alias-map - A map of alias names to target class names.
  *
  * @example:
  * $alias-map: (
  *   alias1: target-class-1,
  *   alias2: target-class-2,
  * );
  * @include create-export-aliases($bem-prefix, $alias-map);
  */
@mixin create-export-aliases($bem-prefix, $alias-map) {

  /* Aliases for easier JS usage (exported as simple keys) */
  @each $alias, $segments in $alias-map {
    $bem-class: $bem-prefix;

    @each $seg in $segments {
      $bem-class: #{$bem-class}#{$seg};
    }

    .#{$alias} {
      composes: #{$bem-class};
    }
  }

}

/**
 * CREATE EXPORT MAPPINGS FOR CSS MODULES (:export)
 * Emits simple key: 'bem-class'; lines which can be injected inside a `:export {}` block.
 * Example usage:
 * :export { @include create-export-alias-exports($bem-prefix, $alias-map); }
 */
@mixin create-export-alias-exports($bem-prefix, $alias-map) {
  @each $alias, $segments in $alias-map {
    $bem-class: $bem-prefix;

    @each $seg in $segments {
      $bem-class: #{$bem-class}#{$seg};
    }

    // output a simple mapping line for :export
    // note: the caller must place this mixin inside a `:export {}` block
    #{$alias}: #{$bem-class};
  }
}